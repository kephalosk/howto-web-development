<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:java="http://www.yworks.com/xml/yfiles-common/1.0/java" xmlns:sys="http://www.yworks.com/xml/yfiles-common/markup/primitives/2.0" xmlns:x="http://www.yworks.com/xml/yfiles-common/markup/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:y="http://www.yworks.com/xml/graphml" xmlns:yed="http://www.yworks.com/xml/yed/3" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd">
  <!--Created by yEd 3.21.1-->
  <key attr.name="Beschreibung" attr.type="string" for="graph" id="d0"/>
  <key for="port" id="d1" yfiles.type="portgraphics"/>
  <key for="port" id="d2" yfiles.type="portgeometry"/>
  <key for="port" id="d3" yfiles.type="portuserdata"/>
  <key attr.name="url" attr.type="string" for="node" id="d4"/>
  <key attr.name="description" attr.type="string" for="node" id="d5"/>
  <key for="node" id="d6" yfiles.type="nodegraphics"/>
  <key for="graphml" id="d7" yfiles.type="resources"/>
  <key attr.name="url" attr.type="string" for="edge" id="d8"/>
  <key attr.name="description" attr.type="string" for="edge" id="d9"/>
  <key for="edge" id="d10" yfiles.type="edgegraphics"/>
  <graph edgedefault="directed" id="G">
    <data key="d0"/>
    <node id="n0">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="20.0" width="161.84756437304623" x="1909.9635304865994" y="3203.248742751808"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="20.1328125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="161.84756437304623" x="4.0" xml:space="preserve" y="-0.06640625">Javascript</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n1">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="20.0" width="70.0" x="2091.811094859646" y="3203.248742751808"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="20.1328125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="70.0" x="4.0" xml:space="preserve" y="-0.06640625">Praxis</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n2">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="20.0" width="296.2946224643531" x="2181.811094859646" y="3203.248742751808"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="20.1328125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="296.2946224643531" x="4.0" xml:space="preserve" y="-0.06640625">3. Modularisierung und Programmierparadigmen</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n3">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="20.0" width="335.9108445272643" x="2498.1057173239988" y="3203.248742751808"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="20.1328125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="335.9108445272643" x="4.0" xml:space="preserve" y="-0.06640625">Closure, Scope und Design Patterns</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n4">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="808.6338496837944" width="600.0" x="2869.016561851263" y="2808.931817909911"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="797.4375" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="5.598174841897162">2. Scope in JavaScript
Was ist Scope?

Scope beschreibt den Gültigkeitsbereich von Variablen und Funktionen in JavaScript. Es gibt zwei Hauptarten von Scopes:

    Globaler Scope: Variablen und Funktionen, die außerhalb aller Funktionen definiert sind, sind global zugänglich.

    Funktionsscope: Variablen und Funktionen, die innerhalb einer Funktion definiert werden, sind nur innerhalb dieser Funktion zugänglich.

Bad Practice: Verwenden von globalen Variablen

let count = 0;  // globale Variable

function increment() {
  count++;
}

function decrement() {
  count--;
}

increment();
decrement();
console.log(count);  // 0, aber potenziell problematisch, da count global ist

Problem: Die Verwendung von globalen Variablen kann zu Namenskonflikten führen und das Debugging erschweren, wenn mehrere Teile des Codes auf die gleiche Variable zugreifen.
Best Practice: Minimierung des globalen Scopes

function counter() {
  let count = 0;  // lokale Variable im Funktionsscope

  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const myCounter = counter();
console.log(myCounter.increment());  // 1
console.log(myCounter.increment());  // 2

Best Practice: Vermeide globale Variablen, indem du Variablen in Funktionsscopes oder Closures kapselst.</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n5">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="320.3155343224248" width="600.0" x="3489.016561851263" y="3053.090975590596"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="302.7890625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="8.763235911212178">function counter() {
  let count = 0;  // lokale Variable im Funktionsscope

  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const myCounter = counter();
console.log(myCounter.increment());  // 1
console.log(myCounter.increment());  // 2</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n6">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="1929.442920965289" width="600.0" x="2869.016561851263" y="3647.5657743326556"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="1913.9296875" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="7.756616732644034">3. Design Patterns in JavaScript
Was sind Design Patterns?

Design Patterns sind bewährte Lösungen für häufig auftretende Probleme in der Softwareentwicklung. In JavaScript gibt es verschiedene Design Patterns, darunter Module Pattern, Singleton Pattern und Observer Pattern.
Bad Practice: Manuelles Erstellen von Modulen

// Manuelles "Modul" ohne Kapselung
function createModule() {
  var secret = 42;

  this.getSecret = function() {
    return secret;
  };
}

const module1 = new createModule();
console.log(module1.secret);  // undefined
console.log(module1.getSecret());  // 42

Problem: Hier wird das Modul direkt als Funktionsinstanz erstellt, ohne die Variablen zu kapseln. Es fehlt eine saubere Trennung zwischen internen und externen Daten.
Best Practice: Modul Pattern mit IIFE (Immediately Invoked Function Expression)

const module = (function() {
  let secret = 42;  // private variable

  return {
    getSecret: function() {
      return secret;
    },
    setSecret: function(value) {
      secret = value;
    }
  };
})();

console.log(module.getSecret());  // 42
module.setSecret(100);
console.log(module.getSecret());  // 100

Best Practice: Das Modul Pattern mit einer IIFE ermöglicht es, private Variablen zu kapseln und bietet nur die öffentliche API an. So bleibt der interne Zustand geschützt.
Singleton Pattern (Ein einziges Exemplar)

Das Singleton Pattern sorgt dafür, dass eine Klasse nur einmal instanziiert wird und immer auf dasselbe Exemplar zugreift.
Bad Practice: Globale Instanziierung

let singleton1 = new Singleton();
let singleton2 = new Singleton();
console.log(singleton1 === singleton2);  // false

Problem: Hier gibt es mehrere Instanzen der Singleton-Klasse, was das Singleton-Muster missachtet.
Best Practice: Singleton Pattern mit geschütztem Konstruktor

const Singleton = (function() {
  let instance;

  function createInstance() {
    return {
      name: "Singleton Instance"
    };
  }

  return {
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();

const singleton1 = Singleton.getInstance();
const singleton2 = Singleton.getInstance();
console.log(singleton1 === singleton2);  // true

Best Practice: Durch das Singleton Pattern wird sichergestellt, dass nur eine Instanz der Klasse existiert, und der Zugriff erfolgt immer auf dieselbe Instanz.
Observer Pattern (Beobachtermuster)

Das Observer Pattern ist ein Verhaltensmuster, das es ermöglicht, dass ein Objekt (Subjekt) seine Beobachter benachrichtigt, wenn sich sein Zustand ändert.
Bad Practice: Direktes Aktualisieren von Abhängigkeiten

let observers = [];
let state = 0;

function addObserver(observer) {
  observers.push(observer);
}

function setState(newState) {
  state = newState;
  observers.forEach(observer =&gt; observer(state));  // Bad Practice: Direkte Abhängigkeit
}

Problem: Hier wird der Zustand direkt in der setState-Funktion verändert und an die Beobachter weitergegeben, ohne eine klare Entkopplung.
Best Practice: Observer Pattern mit Entkopplung

class Subject {
  constructor() {
    this.observers = [];
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  notifyObservers(state) {
    this.observers.forEach(observer =&gt; observer.update(state));
  }
}

class Observer {
  update(state) {
    console.log(`State updated to: ${state}`);
  }
}

const subject = new Subject();
const observer1 = new Observer();
const observer2 = new Observer();

subject.addObserver(observer1);
subject.addObserver(observer2);

subject.notifyObservers(42);  // Beide Observer erhalten die Benachrichtigung

Best Practice: Das Observer Pattern ist hier sauber implementiert, indem die Zustandsaktualisierung und die Benachrichtigung der Beobachter klar getrennt werden.</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n7">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="238.96717493000278" width="600.0" x="3489.016561851263" y="3769.2623775090287"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="232.125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="3.4210874650016194">const module = (function() {
  let secret = 42;  // private variable

  return {
    getSecret: function() {
      return secret;
    },
    setSecret: function(value) {
      secret = value;
    }
  };
})();

console.log(module.getSecret());  // 42
module.setSecret(100);
console.log(module.getSecret());  // 100</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n8">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="223.39753791061912" width="600.0" x="3489.016561851263" y="2412.603545225069"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="217.9921875" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="2.702675205309788">class Person {
    constructor(name, alter) {
        this.name = name;
        this.alter = alter;
    }

    // Methode
    vorstellen() {
        console.log(`Hallo, mein Name ist ${this.name} und ich bin ${this.alter} Jahre alt.`);
    }
}

// Instanziierung
const person1 = new Person("Max", 30);
person1.vorstellen(); // Ausgabe: Hallo, mein Name ist Max und ich bin 30 Jahre alt.</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n9">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="509.25857554603374" width="600.0" x="2869.016561851263" y="2269.673026407362"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="486.515625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="11.37147527301704">. Klassen in JavaScript (ES6 Syntax)

In JavaScript können Klassen seit ECMAScript 6 (ES6) auf eine strukturierte Weise definiert werden. Hier ist ein einfaches Beispiel:
Beispiel: Klasse mit Konstruktor

class Person {
    constructor(name, alter) {
        this.name = name;
        this.alter = alter;
    }

    // Methode
    vorstellen() {
        console.log(`Hallo, mein Name ist ${this.name} und ich bin ${this.alter} Jahre alt.`);
    }
}

// Instanziierung
const person1 = new Person("Max", 30);
person1.vorstellen(); // Ausgabe: Hallo, mein Name ist Max und ich bin 30 Jahre alt.

Bad Practice:

    Konstruktor ohne new verwenden: In JavaScript muss der Konstruktor mit new aufgerufen werden, um eine Instanz der Klasse zu erstellen. Ohne new wird kein Objekt erzeugt, was zu unerwartetem Verhalten führt.

// Bad Practice:
const person2 = Person("Max", 30); // Dies funktioniert nicht korrekt!

Best Practice:

    Verwende immer den new-Operator, um Instanzen zu erstellen.</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n10">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="263.0027325800736" width="600.0" x="3489.016561851263" y="4239.6053129697075"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="260.390625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="1.306053790036458">const Singleton = (function() {
  let instance;

  function createInstance() {
    return {
      name: "Singleton Instance"
    };
  }

  return {
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n11">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="263.0027325800736" width="600.0" x="3489.016561851263" y="4721.966424080819"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="260.390625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="1.306053790036458">const Singleton = (function() {
  let instance;

  function createInstance() {
    return {
      name: "Singleton Instance"
    };
  }

  return {
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n12">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="419.23385730553366" width="600.0" x="3489.016561851263" y="5126.211576003803"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="401.71875" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="8.757553652766546">class Subject {
  constructor() {
    this.observers = [];
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  notifyObservers(state) {
    this.observers.forEach(observer =&gt; observer.update(state));
  }
}

class Observer {
  update(state) {
    console.log(`State updated to: ${state}`);
  }
}

const subject = new Subject();
const observer1 = new Observer();
const observer2 = new Observer();

subject.addObserver(observer1);
subject.addObserver(observer2);

subject.notifyObservers(42);  // Beide Observer erhalten die Benachrichtigung</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <edge id="e0" source="n1" target="n2">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="35.0" sy="-0.0" tx="-148.14731123217655" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e1" source="n0" target="n1">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="80.92378218652311" sy="-0.0" tx="-35.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e2" source="n2" target="n3">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="148.14731123217655" sy="-0.0" tx="-167.95542226363216" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e3" source="n4" target="n5">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="-0.0" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e4" source="n3" target="n4">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="167.95542226363216" sy="-0.0" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e5" source="n3" target="n6">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="167.95542226363216" sy="6.666666666666664" tx="-300.0" ty="-0.0">
            <y:Point x="2853.516561851263" y="3219.9154094184746"/>
            <y:Point x="2853.516561851263" y="4612.2872348153"/>
          </y:Path>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e6" source="n6" target="n7">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="-723.5410953619834" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e7" source="n3" target="n9">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="167.95542226363216" sy="-6.666666666666666" tx="-300.0" ty="-0.0">
            <y:Point x="2853.516561851263" y="3206.5820760851416"/>
            <y:Point x="2853.516561851263" y="2524.302314180379"/>
          </y:Path>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e8" source="n9" target="n8">
      <data key="d9"/>
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="-0.0" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e9" source="n6" target="n10">
      <data key="d9"/>
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="-241.18036512066112" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e10" source="n6" target="n11">
      <data key="d9"/>
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="241.180365120661" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e11" source="n6" target="n12">
      <data key="d9"/>
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="723.5410953619833" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
  </graph>
  <data key="d7">
    <y:Resources/>
  </data>
</graphml>
