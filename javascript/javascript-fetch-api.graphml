<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:java="http://www.yworks.com/xml/yfiles-common/1.0/java" xmlns:sys="http://www.yworks.com/xml/yfiles-common/markup/primitives/2.0" xmlns:x="http://www.yworks.com/xml/yfiles-common/markup/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:y="http://www.yworks.com/xml/graphml" xmlns:yed="http://www.yworks.com/xml/yed/3" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd">
  <!--Created by yEd 3.21.1-->
  <key attr.name="Beschreibung" attr.type="string" for="graph" id="d0"/>
  <key for="port" id="d1" yfiles.type="portgraphics"/>
  <key for="port" id="d2" yfiles.type="portgeometry"/>
  <key for="port" id="d3" yfiles.type="portuserdata"/>
  <key attr.name="url" attr.type="string" for="node" id="d4"/>
  <key attr.name="description" attr.type="string" for="node" id="d5"/>
  <key for="node" id="d6" yfiles.type="nodegraphics"/>
  <key for="graphml" id="d7" yfiles.type="resources"/>
  <key attr.name="url" attr.type="string" for="edge" id="d8"/>
  <key attr.name="description" attr.type="string" for="edge" id="d9"/>
  <key for="edge" id="d10" yfiles.type="edgegraphics"/>
  <graph edgedefault="directed" id="G">
    <data key="d0"/>
    <node id="n0">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="20.0" width="161.84756437304623" x="0.0" y="-1632.4083333333333"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="20.1328125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="161.84756437304623" x="4.0" xml:space="preserve" y="-0.06640625">Javascript</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n1">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="20.0" width="70.0" x="181.84756437304623" y="-1632.4083333333333"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="20.1328125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="70.0" x="4.0" xml:space="preserve" y="-0.06640625">Praxis</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n2">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="20.0" width="231.0" x="271.8475643730462" y="-1632.4083333333333"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="20.1328125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="231.0" x="4.0" xml:space="preserve" y="-0.06640625">2. Asynchrones JavaScript und APIs</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n3">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="20.0" width="223.61215988224444" x="522.8475643730462" y="-1632.4083333333333"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="20.1328125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="223.61215988224444" x="4.0" xml:space="preserve" y="-0.06640625">Daten abrufen mit Fetch-API</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n4">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="648.4562079440476" width="600.0" x="797.4597242552904" y="-1946.636437305357"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="641.9765625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="3.239822722023746">3. Fetch mit POST-Request und Body

❌ Bad Practice – Harte Kodierung des Requests ohne headers:

fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    body: JSON.stringify({ title: 'Neuer Post', body: 'Inhalt des Posts', userId: 1 })
});

&#128308; Problem:

    Fehlende Content-Type-Angabe kann zu unerwartetem Verhalten führen.

    Keine Fehlerbehandlung.

✅ Best Practice – POST-Request mit headers und try/catch:

async function createPost() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ title: 'Neuer Post', body: 'Inhalt des Posts', userId: 1 })
        });

        if (!response.ok) {
            throw new Error(`HTTP Error! Status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Post erstellt:', data);
    } catch (error) {
        console.error('Fehler beim Erstellen des Posts:', error);
    }
}
createPost();

&#128994; Warum?

    headers mit Content-Type: application/json, um sicherzustellen, dass der Server die Daten korrekt verarbeitet.

    try/catch für Fehlerhandling.</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n5">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="313.2476197922965" width="600.0" x="1417.4597242552904" y="-1779.0321432294816"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="302.7890625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="5.229278646148259">async function createPost() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ title: 'Neuer Post', body: 'Inhalt des Posts', userId: 1 })
        });

        if (!response.ok) {
            throw new Error(`HTTP Error! Status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Post erstellt:', data);
    } catch (error) {
        console.error('Fehler beim Erstellen des Posts:', error);
    }
}
createPost();</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n6">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="539.5254006340797" width="600.0" x="797.4597242552904" y="-1268.1801606345002"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="528.9140625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="5.305669067039844">4. Zeitüberschreitungen (Timeouts) handhaben

❌ Bad Practice – Keine Timeout-Behandlung:

fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response =&gt; response.json())
    .then(data =&gt; console.log(data));

&#128308; Problem: Wenn der Server ewig braucht, wartet fetch() unbegrenzt.

✅ Best Practice – fetch() mit Timeout:

function fetchWithTimeout(url, timeout = 5000) {
    const controller = new AbortController();
    const signal = controller.signal;
    setTimeout(() =&gt; controller.abort(), timeout);

    return fetch(url, { signal })
        .then(response =&gt; {
            if (!response.ok) {
                throw new Error(`HTTP Error! Status: ${response.status}`);
            }
            return response.json();
        })
        .catch(error =&gt; {
            if (error.name === 'AbortError') {
                console.error('Anfrage abgebrochen: Timeout');
            } else {
                console.error('Fetch-Fehler:', error);
            }
        });
}
fetchWithTimeout('https://jsonplaceholder.typicode.com/posts/1');

&#128994; Warum?

    AbortController erlaubt Abbruch von Fetch nach einer bestimmten Zeit.</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n7">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="313.2476197922963" width="600.0" x="1417.4597242552904" y="-1155.0412702136084"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="302.7890625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="5.229278646148259">function fetchWithTimeout(url, timeout = 5000) {
    const controller = new AbortController();
    const signal = controller.signal;
    setTimeout(() =&gt; controller.abort(), timeout);

    return fetch(url, { signal })
        .then(response =&gt; {
            if (!response.ok) {
                throw new Error(`HTTP Error! Status: ${response.status}`);
            }
            return response.json();
        })
        .catch(error =&gt; {
            if (error.name === 'AbortError') {
                console.error('Anfrage abgebrochen: Timeout');
            } else {
                console.error('Fetch-Fehler:', error);
            }
        });
}
fetchWithTimeout('https://jsonplaceholder.typicode.com/posts/1');</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n8">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="396.59264471906374" width="600.0" x="797.4597242552904" y="-2901.4141795023893"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="387.5859375" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="4.5033536095320414">Grundlegende Nutzung der Fetch-API

❌ Bad Practice – Fetch ohne Fehlerbehandlung:

fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response =&gt; response.json())
    .then(data =&gt; console.log(data));

&#128308; Problem: Kein Fehlerhandling! Wenn die API fehlschlägt, bleibt der Fehler unbemerkt.

✅ Best Practice – Fetch mit Fehlerbehandlung:

fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response =&gt; {
        if (!response.ok) {
            throw new Error(`HTTP Error! Status: ${response.status}`);
        }
        return response.json();
    })
    .then(data =&gt; console.log(data))
    .catch(error =&gt; console.error('Fehler:', error));

&#128994; Warum?

    Überprüfung von response.ok, um HTTP-Fehler (z. B. 404, 500) zu erkennen.

    catch() fängt Netzwerkausfälle oder Fehler im .then() auf.</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n9">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="197.8425258005209" width="600.0" x="1417.4597242552904" y="-2324.6502311542285"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="189.7265625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="4.057981650260444">async function fetchData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        if (!response.ok) {
            throw new Error(`HTTP Error! Status: ${response.status}`);
        }
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error('Fehler beim Abrufen der Daten:', error);
    }
}
fetchData();</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n10">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="498.1849249310436" width="600.0" x="797.4597242552904" y="-2474.82143071949"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="486.515625" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="5.8346499655217485">2. Verwendung von async/await

❌ Bad Practice – async/await ohne Fehlerbehandlung:

async function fetchData() {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    const data = await response.json();
    console.log(data);
}
fetchData();

&#128308; Problem: Wenn ein Fehler auftritt (z. B. Netzwerkfehler), gibt es keine Fehlerbehandlung.

✅ Best Practice – async/await mit try/catch:

async function fetchData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        if (!response.ok) {
            throw new Error(`HTTP Error! Status: ${response.status}`);
        }
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error('Fehler beim Abrufen der Daten:', error);
    }
}
fetchData();

&#128994; Warum?

    try/catch behandelt Fehler sauber.

    response.ok prüft HTTP-Fehler.</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n11">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="678.6545254215982" width="600.0" x="797.4597242552904" y="-698.6546436631801"/>
          <y:Fill color="#E8EEF7" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="670.2421875" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="4.206168960799118">5. Mehrere API-Anfragen parallel ausführen

❌ Bad Practice – Nacheinander ausgeführte Anfragen:

async function fetchSequentially() {
    const user = await fetch('https://jsonplaceholder.typicode.com/users/1').then(res =&gt; res.json());
    const posts = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=${user.id}`).then(res =&gt; res.json());

    console.log('User:', user);
    console.log('Posts:', posts);
}
fetchSequentially();

&#128308; Problem:

    Jede Anfrage wartet auf die vorherige (await blockiert die nächste Anfrage).

✅ Best Practice – Parallel mit Promise.all():

async function fetchInParallel() {
    try {
        const [userResponse, postsResponse] = await Promise.all([
            fetch('https://jsonplaceholder.typicode.com/users/1'),
            fetch('https://jsonplaceholder.typicode.com/posts?userId=1')
        ]);

        if (!userResponse.ok || !postsResponse.ok) {
            throw new Error('Fehlerhafte Antwort von der API');
        }

        const [user, posts] = await Promise.all([
            userResponse.json(),
            postsResponse.json()
        ]);

        console.log('User:', user);
        console.log('Posts:', posts);
    } catch (error) {
        console.error('Fehler beim Abrufen der Daten:', error);
    }
}
fetchInParallel();

&#128994; Warum?

    Promise.all() führt mehrere fetch()-Aufrufe gleichzeitig aus → schneller.</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n12">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="336.01460431884993" width="600.0" x="1417.4597242552904" y="-527.3346831118059"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="331.0546875" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="2.4799584094249667">async function fetchInParallel() {
    try {
        const [userResponse, postsResponse] = await Promise.all([
            fetch('https://jsonplaceholder.typicode.com/users/1'),
            fetch('https://jsonplaceholder.typicode.com/posts?userId=1')
        ]);

        if (!userResponse.ok || !postsResponse.ok) {
            throw new Error('Fehlerhafte Antwort von der API');
        }

        const [user, posts] = await Promise.all([
            userResponse.json(),
            postsResponse.json()
        ]);

        console.log('User:', user);
        console.log('Posts:', posts);
    } catch (error) {
        console.error('Fehler beim Abrufen der Daten:', error);
    }
}
fetchInParallel();</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <node id="n13">
      <data key="d6">
        <y:GenericNode configuration="com.yworks.flowchart.process">
          <y:Geometry height="142.847488291971" width="600.0" x="1417.4597242552904" y="-2774.5416012888427"/>
          <y:Fill color="#FF99CC" color2="#B7C9E3" transparent="false"/>
          <y:BorderStyle color="#000000" type="line" width="1.0"/>
          <y:NodeLabel alignment="left" autoSizePolicy="node_width" configuration="CroppingLabel" fontFamily="Dialog" fontSize="12" fontStyle="plain" hasBackgroundColor="false" hasLineColor="false" height="133.1953125" horizontalTextPosition="center" iconTextGap="4" modelName="internal" modelPosition="l" textColor="#000000" verticalTextPosition="bottom" visible="true" width="600.0" x="4.0" xml:space="preserve" y="4.826087895985438">fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response =&gt; {
        if (!response.ok) {
            throw new Error(`HTTP Error! Status: ${response.status}`);
        }
        return response.json();
    })
    .then(data =&gt; console.log(data))
    .catch(error =&gt; console.error('Fehler:', error));</y:NodeLabel>
        </y:GenericNode>
      </data>
    </node>
    <edge id="e0" source="n1" target="n2">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="35.0" sy="-0.0" tx="-115.5" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e1" source="n0" target="n1">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="80.92378218652311" sy="-0.0" tx="-35.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e2" source="n2" target="n3">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="115.5" sy="-0.0" tx="-111.80607994112222" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e3" source="n4" target="n5">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="-0.0" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e4" source="n3" target="n4">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="111.80607994112222" sy="-0.0" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e5" source="n3" target="n6">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="111.80607994112222" sy="4.0" tx="-300.0" ty="-0.0">
            <y:Point x="781.9597242552906" y="-1618.4083333333333"/>
            <y:Point x="781.9597242552906" y="-998.4174603174603"/>
          </y:Path>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e6" source="n6" target="n7">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="-0.0" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e7" source="n3" target="n8">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="111.80607994112222" sy="-8.0" tx="-300.0" ty="-0.0">
            <y:Point x="765.9597242552906" y="-1630.4083333333333"/>
            <y:Point x="765.9597242552906" y="-2703.1178571428572"/>
          </y:Path>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e8" source="n3" target="n10">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="111.80607994112222" sy="-4.0" tx="-300.0" ty="-0.0">
            <y:Point x="781.9597242552906" y="-1626.4083333333333"/>
            <y:Point x="781.9597242552906" y="-2225.728968253968"/>
          </y:Path>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e9" source="n11" target="n12">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="-0.0" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e10" source="n3" target="n11">
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="111.80607994112222" sy="8.0" tx="-300.0" ty="-0.0">
            <y:Point x="765.9597242552906" y="-1614.4083333333333"/>
            <y:Point x="765.9597242552906" y="-359.32738095238096"/>
          </y:Path>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e11" source="n10" target="n9">
      <data key="d9"/>
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="-0.0" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
    <edge id="e12" source="n8" target="n13">
      <data key="d9"/>
      <data key="d10">
        <y:PolyLineEdge>
          <y:Path sx="300.0" sy="-0.0" tx="-300.0" ty="-0.0"/>
          <y:LineStyle color="#000000" type="line" width="1.0"/>
          <y:Arrows source="none" target="standard"/>
          <y:BendStyle smoothed="false"/>
        </y:PolyLineEdge>
      </data>
    </edge>
  </graph>
  <data key="d7">
    <y:Resources/>
  </data>
</graphml>
